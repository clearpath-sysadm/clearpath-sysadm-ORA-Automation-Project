import logging
from google.cloud import secretmanager
from googleapiclient.errors import HttpError # Imported for HttpError handling
import time # Imported for time.sleep in retry logic

# Setup logging for this module. This assumes setup_logging from utils.logging_config
# has already been called in the main application entry point.
logger = logging.getLogger(__name__)

def access_secret_version(project_id: str, secret_id: str, version_id: str = "latest", credentials_path: str = None) -> str | None:
    """
    Accesses the payload for the given secret version from Google Secret Manager.
    
    This function includes retry logic for HttpError 503 (Service Unavailable)
    and explicitly uses `credentials_path` if provided, otherwise it defaults
    to Application Default Credentials (ADC). It logs information and errors
    using the configured logging system.

    Args:
        project_id (str): The ID of the Google Cloud project where the secret is stored.
        secret_id (str): The ID of the secret to access.
        version_id (str): The version of the secret to access (e.g., "latest", "1", "2").
                          Defaults to "latest".
        credentials_path (str, optional): Path to a service account JSON key file.
                                          If None, Application Default Credentials are used.

    Returns:
        str | None: The payload of the secret decoded as UTF-8, or None if an error occurs.
    """
    max_retries = 10
    initial_delay = 1  # seconds

    for attempt in range(max_retries):
        try:
            # Initialize the Secret Manager client.
            # If a credentials_path is provided, use it; otherwise, rely on ADC.
            if credentials_path:
                client = secretmanager.SecretManagerServiceClient.from_service_account_json(credentials_path)
            else:
                client = secretmanager.SecretManagerServiceClient()

            # Build the resource name of the secret version.
            name = client.secret_version_path(project_id, secret_id, version_id)

            # Access the secret version.
            response = client.access_secret_version(request={"name": name})

            # Decode the payload.
            payload = response.payload.data.decode("UTF-8")
            logger.info(f"Successfully accessed secret: {secret_id}")
            return payload

        except HttpError as e:
            # Handle HttpError 503 (Service Unavailable) with retry logic.
            if e.resp.status == 503:
                logger.warning(
                    f"HttpError 503 (Service Unavailable) accessing Secret Manager '{secret_id}'. "
                    f"Retrying in {initial_delay}s... (Attempt {attempt + 1}/{max_retries})"
                )
                time.sleep(initial_delay)
                initial_delay *= 2  # Exponential backoff
            else:
                # Log other HTTP errors without retrying.
                logger.error(
                    f"HttpError accessing secret '{secret_id}' version '{version_id}' in project '{project_id}': {e}",
                    exc_info=True # Log full traceback
                )
                return None
        except FileNotFoundError:
            logger.error(
                f"Error: Service account file not found at '{credentials_path}'. "
                f"Please check the path for secret '{secret_id}'.",
                exc_info=True
            )
            return None
        except Exception as e:
            # Catch any other unexpected errors during secret access.
            logger.error(
                f"An unexpected error occurred accessing secret '{secret_id}' version '{version_id}' "
                f"in project '{project_id}': {e}",
                exc_info=True
            )
            return None
    
    # If all retries fail due to HttpError 503.
    logger.error(
        f"Failed to retrieve secret '{secret_id}' after {max_retries} retries due to persistent HttpError 503."
    )
    return None

# This block is for independent testing of the module.
# In a real application, the main script would import and call this function.
if __name__ == "__main__":
    # Example usage for testing purposes.
    # In a real scenario, YOUR_GCP_PROJECT_ID and SECRET_IDs would come from config.
    # Dummy values are used here for demonstration.
    
    # Simulate setup_logging from utils.logging_config
    # In a real application, ensure your main script calls setup_logging once.
    logging.basicConfig(level=logging.INFO, 
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    test_project_id = "ora-automation-project" # Replace with your actual GCP project ID
    test_secret_id = "shipstation-api-secret" # Replace with a test secret ID
    test_credentials_path = r"C:\Users\NathanNeely\Projects\ORA_Automation\config\ora-automation-project-2345f75740f8.json"
    logger.info(f"Attempting to access dummy secret '{test_secret_id}' in project '{test_project_id}'...")

    # NOTE: This call will likely fail unless you replace the dummy values with
    # actual, accessible secrets and a valid credentials path/ADC setup.
    # It serves to demonstrate the function's expected behavior and logging.
    secret_payload = access_secret_version(
        project_id=test_project_id,
        secret_id=test_secret_id,
        credentials_path=test_credentials_path
    )

    if secret_payload:
        logger.info(f"Successfully retrieved secret (truncated): {secret_payload[:10]}...")
    else:
        logger.error("Failed to retrieve the secret. Check logs for details.")

