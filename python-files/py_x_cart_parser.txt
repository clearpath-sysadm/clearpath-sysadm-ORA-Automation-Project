import xml.etree.ElementTree as ET
import datetime
import pandas as pd
import logging
import os # <--- ADDED THIS IMPORT

# Setup logging for this module. This assumes setup_logging from utils.logging_config
# has already been called in the main application entry point.
logger = logging.getLogger(__name__)

def parse_date(date_string: str) -> str | None:
    """
    Parses multiple date formats from an XML string into an ISO 8601 formatted string
    suitable for the ShipStation API (e.g., 'YYYY-MM-DDTHH:MM:SS.sssZ').
    
    Handles 'Z' for UTC and different precisions. Logs a warning if parsing fails.

    Args:
        date_string (str): The date string to parse from the XML.

    Returns:
        str | None: The parsed date string in ISO 8601 format with milliseconds and 'Z' for UTC,
                    or the original string if parsing fails, or None if input is None.
    """
    if date_string is None:
        return None

    formats_to_try = [
        '%Y-%m-%d %H:%M:%S',      # 2025-05-29 07:34:57 (common format)
        '%Y-%m-%dT%H:%M:%S.%fZ',  # 2023-10-26T10:00:00.000000Z (with microseconds and Z)
        '%Y-%m-%dT%H:%M:%SZ',     # 2023-10-26T10:00:00Z (with Z)
        '%Y-%m-%dT%H:%M:%S',      # 2023-10-26T10:00:00 (without Z)
        '%m/%d/%Y %H:%M',         # 5/1/2025 10:30
        '%m/%d/%Y %I:%M:%S %p'    # 5/1/2025 10:30:00 AM
    ]

    for fmt in formats_to_try:
        try:
            # Attempt to parse the date string.
            dt_obj = datetime.datetime.strptime(date_string, fmt)
            # Standardize to ISO 8601 with milliseconds and 'Z' for UTC (ShipStation's preference).
            # Using astimezone(datetime.timezone.utc) ensures it's truly UTC before adding 'Z'.
            return dt_obj.astimezone(datetime.timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z')
        except ValueError:
            continue # Try the next format if the current one fails.
        except Exception as e:
            logger.debug(f"Error parsing date '{date_string}' with format '{fmt}': {e}")
            continue # Continue to next format on unexpected errors as well

    # If no format matches after trying all, log a warning and return the original string.
    logger.warning(f"Unable to parse date: '{date_string}' with known formats. Returning original string.")
    return date_string # Return original string; ShipStation API might handle some variations.

def build_address_from_xml(order_element: ET.Element, address_prefix: str) -> dict:
    """
    Builds an address dictionary from an XML element using the given prefix (e.g., 's_' for ship, 'b_' for bill).
    Extracts common address fields and performs basic cleaning.

    Args:
        order_element (xml.etree.ElementTree.Element): The XML element representing an order.
        address_prefix (str): The prefix used in XML tags for address fields (e.g., 's_' or 'b_').

    Returns:
        dict: A dictionary containing standardized address fields like 'name', 'company',
              'street1', 'city', 'state', 'postalCode', 'country', 'phone'.
    """
    address = {}

    # Safely get text, defaulting to an empty string if the element is not found (None).
    firstname = order_element.findtext(f'{address_prefix}firstname') or ""
    lastname = order_element.findtext(f'{address_prefix}lastname') or ""

    address["name"] = (firstname + " " + lastname).strip() # Combine first and last name
    address["company"] = order_element.findtext(f'{address_prefix}company') or ""
    address["street1"] = order_element.findtext(f'{address_prefix}address') or ""
    address["city"] = order_element.findtext(f'{address_prefix}city') or ""
    address["state"] = order_element.findtext(f'{address_prefix}state') or ""
    address["postalCode"] = order_element.findtext(f'{address_prefix}zipcode') or ""
    address["country"] = order_element.findtext(f'{address_prefix}country') or ""
    address["phone"] = order_element.findtext(f'{address_prefix}phone') or ""

    # Basic cleaning for street1: remove non-ASCII control characters and trim whitespace.
    if address["street1"]:
        # This emulates PowerShell's -replace '[^\P{C}\p{Zs}]', '').Trim()
        # \P{C} matches any non-control character. \p{Zs} matches any space separator.
        # So, [^\P{C}\p{Zs}] matches anything that is *not* a non-control char AND *not* a space separator.
        # Effectively, it targets control characters and other non-printable characters.
        address["street1"] = address["street1"].encode('ascii', 'ignore').decode('ascii').strip()
    return address

def parse_x_cart_xml_for_shipstation_payload(xml_file_path: str, bundle_config: dict) -> list[dict]:
    """
    Parses an X-Cart XML file, applies product bundling logic, and prepares a list of orders
    formatted for ShipStation's /orders/createorders endpoint.

    Args:
        xml_file_path (str): The full path to the X-Cart XML file.
        bundle_config (dict): A dictionary defining product bundles. Keys are bundle SKUs,
                              values are either a dict (single component) or a list of dicts (multi-component),
                              specifying component_id and multiplier.

    Returns:
        list[dict]: A list of dictionaries, where each dictionary represents an order
                    ready to be sent to ShipStation. Returns an empty list if an error occurs
                    or no valid orders are found.
    """
    orders_payload = []
    try:
        # Parse the XML file.
        tree = ET.parse(xml_file_path)
        root = tree.getroot()

        # Iterate through each 'order' element in the XML.
        for order_element in root.findall('order'):
            order_data = {}
            # Extract basic order information. Use findtext for safe extraction.
            order_data['orderKey'] = order_element.findtext('orderid')
            order_data['orderNumber'] = order_element.findtext('orderid')

            order_date_raw = order_element.findtext('date2')
            order_data['orderDate'] = parse_date(order_date_raw) if order_date_raw else None
            
            order_data['orderStatus'] = 'awaiting_shipment' # Default status
            order_data['customerEmail'] = order_element.findtext('email')
            order_data['requestedShippingService'] = order_element.findtext('shipping')

            # Build billing and shipping addresses using the helper function.
            order_data['billTo'] = build_address_from_xml(order_element, "b_")
            order_data['shipTo'] = build_address_from_xml(order_element, "s_")

            items_list = []
            # Iterate through each 'order_detail' (item) within the order.
            for order_detail_element in order_element.findall('order_detail'):
                original_sku = order_detail_element.findtext('productid')
                original_quantity_str = order_detail_element.findtext('amount')
                product_name = order_detail_element.findtext('product')

                # Parse quantity safely.
                try:
                    original_quantity = int(original_quantity_str) if original_quantity_str else 0
                except ValueError:
                    logger.warning(
                        f"Non-numeric quantity '{original_quantity_str}' for SKU '{original_sku}' "
                        f"in Order {order_data.get('orderNumber', 'N/A')}. Defaulting to 0."
                    )
                    original_quantity = 0
                
                # Parse dimensions and weight safely, defaulting to 0 if not found.
                weight_value = float(order_detail_element.findtext('weight_oz') or '0')
                height = float(order_detail_element.findtext('height_in') or '0')
                length = float(order_detail_element.findtext('length_in') or '0')
                width = float(order_detail_element.findtext('width_in') or '0')

                # Log a warning if dimensions/weight are missing.
                if (order_detail_element.findtext('weight_oz') is None and
                    order_detail_element.findtext('height_in') is None and
                    order_detail_element.findtext('length_in') is None and
                    order_detail_element.findtext('width_in') is None):
                    logger.warning(
                        f"Dimensions/weight not found for item SKU {original_sku} "
                        f"in Order {order_data.get('orderNumber', 'N/A')}. Defaulting to 0."
                    )

                # Skip if SKU is missing or quantity is zero.
                if original_sku is None or original_sku == '' or original_quantity == 0:
                    logger.debug(
                        f"Skipping shipment item with missing SKU ('{original_sku}') or zero quantity ({original_quantity}) "
                        f"for Order: {order_data.get('orderNumber', 'N/A')}"
                    )
                    continue

                # Apply bundling logic.
                if original_sku in bundle_config:
                    bundle_def = bundle_config[original_sku]
                    if isinstance(bundle_def, dict): # Single component bundle (e.g., {"component_id": "123", "multiplier": 5})
                        component_sku = bundle_def.get('component_id')
                        multiplier = bundle_def.get('multiplier', 1)
                        expanded_quantity = original_quantity * multiplier
                        items_list.append({
                            "sku": component_sku,
                            "name": product_name, # Use original product name for the component
                            "quantity": expanded_quantity,
                            "weight": {"value": weight_value, "units": "ounces"},
                            "dimensions": {"height": height, "length": length, "width": width}
                        })
                        logger.debug(
                            f"Expanded bundle {original_sku} to {expanded_quantity}x {component_sku} "
                            f"for Order {order_data['orderNumber']} (Single Component Bundle)."
                        )
                    elif isinstance(bundle_def, list): # Multi-component bundle (e.g., [{"component_id": "A", "multiplier": 2}, {"component_id": "B", "multiplier": 1}])
                        for component_info in bundle_def:
                            component_sku = component_info.get('component_id')
                            multiplier = component_info.get('multiplier', 1)
                            expanded_quantity = original_quantity * multiplier
                            items_list.append({
                                "sku": component_sku,
                                "name": product_name, # Use original product name for the component
                                "quantity": expanded_quantity,
                                "weight": {"value": weight_value, "units": "ounces"},
                                "dimensions": {"height": height, "length": length, "width": width}
                            })
                            logger.debug(
                                f"Expanded multi-component bundle {original_sku} to {expanded_quantity}x {component_sku} "
                                f"for Order {order_data['orderNumber']} (Multi-Component Bundle)."
                            )
                else:
                    # If not a bundle, add the item as-is.
                    items_list.append({
                        "sku": original_sku,
                        "name": product_name,
                        "quantity": original_quantity,
                        "weight": {"value": weight_value, "units": "ounces"},
                        "dimensions": {"height": height, "length": length, "width": width}
                    })
            
            # Add the processed items to the current order data.
            order_data['items'] = items_list
            # Add the complete order data to the overall payload.
            orders_payload.append(order_data)
            logger.debug(f"Processed Order {order_data.get('orderNumber', 'N/A')} with {len(items_list)} items.")

    except FileNotFoundError:
        logger.error(f"Error: The XML file '{xml_file_path}' was not found.", exc_info=True)
        return []
    except ET.ParseError as e:
        logger.error(f"Error parsing XML file '{xml_file_path}': {e}", exc_info=True)
        return []
    except Exception as e:
        logger.critical(f"An unexpected error occurred during XML processing: {e}", exc_info=True)
        return []
        
    return orders_payload

# This block is for independent testing of the module.
if __name__ == "__main__":
    # Simulate logging setup for independent module testing
    logging.basicConfig(level=logging.DEBUG, # Use DEBUG to see detailed parsing logs
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    # --- DUMMY CONFIGURATION FOR TESTING ---
    # In a real application, X_CART_XML_PATH and BUNDLE_CONFIG would come from a central config.
    # Create a 'test_data' directory within 'src' if it doesn't exist.
    test_data_dir = os.path.join(os.path.dirname(__file__), '..', 'test_data')
    os.makedirs(test_data_dir, exist_ok=True)
    DUMMY_X_CART_XML_PATH = os.path.join(test_data_dir, "x_cart_orders_bundle_test.xml") # Path for dummy XML
    
    # Example XML content to be saved to DUMMY_X_CART_XML_PATH:
    xml_content = """
    <orders>
      <order>
        <orderid>1001</orderid>
        <date2>2025-06-25 10:00:00</date2>
        <email>customer1@example.com</email>
        <shipping>Flat Rate</shipping>
        <b_firstname>Bill</b_firstname><b_lastname>Buyer</b_lastname><b_address>123 Billing St</b_address><b_city>Billtown</b_city><b_state>TX</b_state><b_zipcode>10001</b_zipcode><b_country>US</b_country><b_phone>555-1111</b_phone>
        <s_firstname>Ship</s_firstname><s_lastname>Receiver</s_lastname><s_address>456 Shipping Ave</s_address><s_city>Shiptown</s_city><s_state>NY</s_state><s_zipcode>20001</s_zipcode><s_country>US</s_country><s_phone>555-2222</s_phone>
        <order_detail>
          <productid>17612</productid> <!-- Non-bundle SKU -->
          <product>OraCare Health Rinse</product>
          <amount>2</amount>
          <weight_oz>32</weight_oz><height_in>8</height_in><length_in>4</length_in><width_in>4</width_in>
        </order_detail>
        <order_detail>
          <productid>18225</productid> <!-- Single-component bundle SKU (OraCare Buy 30 Get 8 Free -> 40x 17612) -->
          <product>OraCare Bundle 30+8</product>
          <amount>1</amount>
          <weight_oz>100</weight_oz><height_in>15</height_in><length_in>10</length_in><width_in>10</width_in>
        </order_detail>
        <order_detail>
          <productid>18605</productid> <!-- Multi-component bundle SKU -->
          <product>Multi-Pack Special</product>
          <amount>1</amount>
          <weight_oz>50</weight_oz><height_in>10</height_in><length_in>8</length_in><width_in>6</width_in>
        </order_detail>
         <order_detail>
          <productid>99999</productid> <!-- SKU not in bundle config -->
          <product>Unknown Product</product>
          <amount>3</amount>
          <weight_oz>10</weight_oz><height_in>2</height_in><length_in>2</length_in><width_in>2</width_in>
        </order_detail>
      </order>
    </orders>
    """
    # Save the dummy XML content to the file
    with open(DUMMY_X_CART_XML_PATH, "w") as f:
        f.write(xml_content)
    logger.info(f"Dummy XML file created at: {DUMMY_X_CART_XML_PATH}")


    DUMMY_BUNDLE_CONFIG = {
        "18075": {"component_id": "17913", "multiplier": 1},
        "18225": {"component_id": "17612", "multiplier": 40},
        "18605": [ # Example from your actual BUNDLE_CONFIG
            {"component_id": "17612", "multiplier": 4},
            {"component_id": "17914", "multiplier": 1},
            {"component_id": "17904", "multiplier": 1},
        ],
        "NON_EXISTENT_BUNDLE": {"component_id": "FAKE", "multiplier": 1} # For testing non-matches
    }

    logger.info("Starting independent test of X-Cart Parser module...")

    # Ensure the dummy XML file exists for testing (already created above, but check for safety)
    if not os.path.exists(DUMMY_X_CART_XML_PATH):
        logger.warning(f"Dummy XML file '{DUMMY_X_CART_XML_PATH}' not found. "
                       "Please ensure it's created or specify a valid path. Skipping parsing test.")
    else:
        parsed_orders = parse_x_cart_xml_for_shipstation_payload(DUMMY_X_CART_XML_PATH, DUMMY_BUNDLE_CONFIG)

        if parsed_orders:
            logger.info(f"Successfully parsed {len(parsed_orders)} orders.")
            for i, order in enumerate(parsed_orders):
                logger.info(f"Order {i+1} (OrderNumber: {order.get('orderNumber')}, Items: {len(order.get('items', []))}):")
                for item in order.get('items', []):
                    logger.info(f"  SKU: {item.get('sku')}, Qty: {item.get('quantity')}, Name: {item.get('name')}")
        else:
            logger.warning("No orders parsed or an error occurred during parsing.")

    logger.info("Independent test of X-Cart Parser module finished.")
