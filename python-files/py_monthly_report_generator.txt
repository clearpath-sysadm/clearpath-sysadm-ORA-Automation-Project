import pandas as pd
import datetime
import math
import logging
import os
import sys

# Add the project root to the Python path to enable imports from utils and services
# This path is relative to the current file (report_data_loader.py)
# report_data_loader.py is in ORA_Automation/src/services/reporting_logic/
# So, to get to ORA_Automation, we need to go up three levels (reporting_logic, services, src).
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Import necessary modules from our services layer
from src.services.google_sheets.sheets_api import write_google_sheet_data
from src.services.data_processing.shipment_processor import process_shipstation_shipments_to_daily_df
from src.services.reporting_logic.inventory_calculations import calculate_daily_inventory

# Setup logging for this module. This assumes setup_logging from utils.logging_config
# has already been called in the main application entry point.
logger = logging.getLogger(__name__)

def generate_monthly_charge_report(
    # Note: api_key, api_secret are not directly used in this function's calculations
    # but might be passed through from the main orchestrator if this module
    # were to directly fetch data from ShipStation, which it currently doesn't.
    # Keeping them in the signature for now if the main script passes them for consistency.
    shipstation_api_key: str, # Not directly used in *this* module, but part of main script's parameters
    shipstation_api_secret: str, # Not directly used in *this* module, but part of main script's parameters
    
    # Google Sheets related parameters
    google_sheet_id: str, 
    monthly_charge_report_tab_name: str, 
    service_account_credentials_path: str,

    # Configuration data
    initial_inventory_map: dict, 
    pallet_counts: dict, 
    rates: dict, 
    
    # Raw input data
    raw_golden_test_data_raw: list[list], 
    inventory_transactions_raw: list[list],
    
    # Global Bundle Config (needed by shipment_processor)
    bundle_config: dict # Pass the global BUNDLE_CONFIG here
) -> tuple[pd.DataFrame, pd.DataFrame]:
    """
    Orchestrates the generation and writing of the Monthly Charge Report.
    
    This function handles:
    1. Processing raw shipment data (ShippedItem and ShippedOrder types) using shipment_processor.
    2. Aggregating daily shipped quantities and unique order counts.
    3. Calculating daily inventory (BOD/EOD) using inventory_calculations.
    4. Calculating charges (Orders, Packages, Space Rental).
    5. Formatting and writing the daily report and monthly totals to Google Sheets.

    Args:
        shipstation_api_key (str): ShipStation API Key. (Not directly used in calculations here)
        shipstation_api_secret (str): ShipStation API Secret. (Not directly used in calculations here)
        google_sheet_id (str): ID of the Google Sheet.
        monthly_charge_report_tab_name (str): Name of the monthly report tab in Google Sheet.
        service_account_credentials_path (str): Path to Google service account JSON key.
        initial_inventory_map (dict): Map of SKU to initial inventory quantity.
        pallet_counts (dict): Map of SKU to units per pallet.
        rates (dict): Map of charge rates (e.g., 'OrderCharge', 'PackageCharge', 'SpaceRentalRate').
        raw_golden_test_data_raw (list[list]): Raw data from 'Golden_Test_Data_Raw' sheet.
        inventory_transactions_raw (list[list]): Raw data from 'Inventory_TRANSACTIONS' sheet.
        bundle_config (dict): Configuration for product bundles to expand items.

    Returns:
        tuple[pd.DataFrame, pd.DataFrame]: A tuple containing:
            - DailyInventory_DF (pd.DataFrame): DataFrame of daily inventory (BOD/EOD).
            - DailyShippedSKUQty_DF (pd.DataFrame): DataFrame of daily shipped quantities per SKU.
            These are returned as they are inputs for other reports (e.g., Weekly Report).
    """
    logger.info("Generating Monthly Charge Report...")
    
    if not raw_golden_test_data_raw or len(raw_golden_test_data_raw) < 2:
        logger.warning("No data or malformed data provided for Golden Test Data Raw. Returning empty DataFrames for Monthly Report.")
        return pd.DataFrame(), pd.DataFrame()

    # Extract headers and data rows from raw golden test data.
    headers_golden_raw = [h.strip() for h in raw_golden_test_data_raw[0]]
    data_rows_golden_raw = raw_golden_test_data_raw[1:]

    # Separate 'ShippedItem' transactions for quantity processing.
    shipped_item_data_dicts = []
    for row in data_rows_golden_raw:
        if len(row) == len(headers_golden_raw): # Ensure row length matches headers
            row_dict = dict(zip(headers_golden_raw, row))
            if row_dict.get('Transaction_Type') == 'ShippedItem':
                shipped_item_data_dicts.append(row_dict)
        else:
            logger.warning(f"Skipping malformed row in Golden_Test_Data_Raw: {row}")
    
    # Process shipped items to get flattened quantities with bundle expansion.
    processed_shipped_items_df = process_shipstation_shipments_to_daily_df(
        shipped_item_data_dicts, # Pass only ShippedItem data
        bundle_config # Pass bundle config here
    )
    logger.info(f"Processed Shipped Items (from ShippedItem) DataFrame. Shape: {processed_shipped_items_df.shape}")
    logger.debug(f"Head:\n{processed_shipped_items_df.head()}")

    # Separate 'ShippedOrder' transactions for unique order counting.
    shipped_order_data_dicts = []
    for row in data_rows_golden_raw:
        if len(row) == len(headers_golden_raw): # Ensure row length matches headers
            row_dict = dict(zip(headers_golden_raw, row))
            if row_dict.get('Transaction_Type') == 'ShippedOrder':
                shipped_order_data_dicts.append(row_dict)
        else:
             logger.warning(f"Skipping malformed row in Golden_Test_Data_Raw for ShippedOrder: {row}")

    order_count_source_df = pd.DataFrame(shipped_order_data_dicts)

    # Process order count source DataFrame to ensure correct date and order number types.
    if not order_count_source_df.empty:
        order_count_source_df['Date'] = pd.to_datetime(order_count_source_df['Date'])
        # Clean 'Order_Number' column: strip whitespace, convert 'NULL' or empty to None.
        order_count_source_df['OrderNumber'] = order_count_source_df['Order_Number'].apply( 
            lambda x: str(x).strip() if x is not None else ''
        ).apply(
            lambda x: None if x.upper() == 'NULL' or x == '' else x
        )
    else:
        # If no shipped order data, create an empty DataFrame with expected columns.
        order_count_source_df = pd.DataFrame(columns=['Date', 'OrderNumber'])

    logger.info(f"Raw ShippedOrder Data for Order Counting. Shape: {order_count_source_df.shape}")
    logger.debug(f"Head:\n{order_count_source_df.head()}")
    
    # Determine the overall date range for the report based on all processed data.
    all_dates_list = []
    if not processed_shipped_items_df.empty:
        all_dates_list.extend(processed_shipped_items_df['Date'].tolist())
    if not order_count_source_df.empty:
        all_dates_list.extend(order_count_source_df['Date'].tolist())

    if all_dates_list:
        report_start_date = pd.to_datetime(all_dates_list).min().date()
        report_end_date = pd.to_datetime(all_dates_list).max().date()
    else:
        # If no dates available, default to today.
        report_start_date = datetime.date.today()
        report_end_date = datetime.date.today()

    # Create a full date range covering the report period.
    all_dates = pd.to_datetime(pd.date_range(start=report_start_date, end=report_end_date, freq='D').normalize()) 
    
    # Get all SKUs from the pallet_counts (which should cover all relevant SKUs for inventory).
    all_skus = list(pallet_counts.keys()) 

    # Aggregate processed shipped items to daily quantities per SKU.
    DailyShippedSKUQty_DF = processed_shipped_items_df.groupby(['Date', 'BaseSKU'])['QuantityShipped'].sum().reset_index()
    DailyShippedSKUQty_DF.rename(columns={'QuantityShipped': 'TotalQtyShipped', 'BaseSKU': 'SKU'}, inplace=True) 
    DailyShippedSKUQty_DF['Date'] = pd.to_datetime(DailyShippedSKUQty_DF['Date']).dt.normalize()
    
    # Calculate daily unique order counts.
    DailyOrderCount_DF = order_count_source_df[order_count_source_df['OrderNumber'].notna()].groupby('Date')['OrderNumber'].nunique().reset_index()
    DailyOrderCount_DF.rename(columns={'OrderNumber': 'CountOfOrders'}, inplace=True) 
    DailyOrderCount_DF['Date'] = pd.to_datetime(DailyOrderCount_DF['Date']).dt.normalize()

    logger.info(f"Daily Aggregated Shipments (from ShippedItem). Shape: {DailyShippedSKUQty_DF.shape}")
    logger.debug(f"Head:\n{DailyShippedSKUQty_DF.head()}")
    logger.info(f"Daily Order Count (from ShippedOrder). Shape: {DailyOrderCount_DF.shape}")
    logger.debug(f"Head:\n{DailyOrderCount_DF.head()}")

    # Prepare inventory transactions DataFrame.
    inventory_transactions_df = pd.DataFrame() 
    if inventory_transactions_raw and len(inventory_transactions_raw) > 1:
        headers = [h.strip() for h in inventory_transactions_raw[0]]
        data_rows = inventory_transactions_raw[1:]
        if headers: 
            inventory_transactions_df = pd.DataFrame(data_rows, columns=headers)
            # Ensure 'Date' and 'Quantity' columns are in correct types.
            if 'Date' in inventory_transactions_df.columns:
                try:
                    inventory_transactions_df['Date'] = pd.to_datetime(inventory_transactions_df['Date'])
                except Exception as e:
                    logger.warning(f"Could not convert 'Date' column to datetime in Inventory_Transactions. Details: {e}", exc_info=True)
            if 'Quantity' in inventory_transactions_df.columns:
                try:
                    inventory_transactions_df['Quantity'] = pd.to_numeric(inventory_transactions_df['Quantity'], errors='coerce').fillna(0)
                except Exception as e:
                    logger.warning(f"Could not convert 'Quantity' column to numeric in Inventory_Transactions. Details: {e}", exc_info=True)
        else:
            logger.error("Inventory_Transactions sheet has no headers. Returning empty DataFrame for transactions.")
    else:
        logger.warning("No data or malformed data retrieved from Inventory_Transactions sheet. Returning empty DataFrame for transactions.")
    
    if 'Date' in inventory_transactions_df.columns:
        inventory_transactions_df['Date'] = pd.to_datetime(inventory_transactions_df['Date']).dt.normalize()
    
    # Prepare daily movements for inventory calculation.
    # Consolidate Shipped, Received, Repacked quantities onto a single daily SKU movement DataFrame.
    DailyShippedSKUQty_DF['Date'] = pd.to_datetime(DailyShippedSKUQty_DF['Date']).dt.normalize()
    DailyShippedSKUQty_DF['SKU'] = DailyShippedSKUQty_DF['SKU'].astype(str) 

    received_df = inventory_transactions_df[inventory_transactions_df['TransactionType'] == 'Receive'].groupby(['Date', 'SKU'])['Quantity'].sum().reset_index()
    received_df.rename(columns={'Quantity': 'ReceivedQty'}, inplace=True)
    received_df['SKU'] = received_df['SKU'].astype(str) 

    repacked_df = inventory_transactions_df[inventory_transactions_df['TransactionType'] == 'Repack'].groupby(['Date', 'SKU'])['Quantity'].sum().reset_index()
    repacked_df.rename(columns={'Quantity': 'RepackedQty'}, inplace=True)
    repacked_df['SKU'] = repacked_df['SKU'].astype(str) 

    # Create a full grid of all date-SKU combinations to ensure all days are represented.
    all_date_sku_combinations = pd.MultiIndex.from_product([all_dates, all_skus], names=['Date', 'SKU']).to_frame(index=False)
    all_date_sku_combinations['SKU'] = all_date_sku_combinations['SKU'].astype(str) 

    # Merge all daily movement types.
    AllDailySKUMovements_DF = pd.merge(
        all_date_sku_combinations,
        DailyShippedSKUQty_DF, 
        on=['Date', 'SKU'],
        how='left'
    ).fillna({'TotalQtyShipped': 0}) 
    AllDailySKUMovements_DF.rename(columns={'TotalQtyShipped': 'ShippedQty'}, inplace=True) 

    AllDailySKUMovements_DF = pd.merge(
        AllDailySKUMovements_DF,
        received_df,
        on=['Date', 'SKU'],
        how='left'
    ).fillna({'ReceivedQty': 0})

    AllDailySKUMovements_DF = pd.merge(
        AllDailySKUMovements_DF,
        repacked_df,
        on=['Date', 'SKU'],
        how='left'
    ).fillna({'RepackedQty': 0})

    AllDailySKUMovements_DF['ShippedQty'] = AllDailySKUMovements_DF['ShippedQty'].astype(int)
    AllDailySKUMovements_DF['ReceivedQty'] = AllDailySKUMovements_DF['ReceivedQty'].astype(int)
    AllDailySKUMovements_DF['RepackedQty'] = AllDailySKUMovements_DF['RepackedQty'].astype(int)

    logger.info(f"All Daily SKU Movements prepared. Shape: {AllDailySKUMovements_DF.shape}")
    logger.debug(f"Head:\n{AllDailySKUMovements_DF.head()}")

    # Filter initial inventory map to only include SKUs being processed for daily inventory.
    initial_inventory_for_calc = {
        sku: initial_inventory_map.get(sku, 0) 
        for sku in all_skus
    }

    # Calculate daily inventory using the imported function.
    DailyInventory_DF = calculate_daily_inventory(
        initial_inventory_for_calc, 
        all_skus, 
        all_dates, 
        AllDailySKUMovements_DF[['Date', 'SKU', 'ShippedQty', 'ReceivedQty', 'RepackedQty']] 
    )

    logger.info(f"Daily Inventory (BOD/EOD) calculated. Shape: {DailyInventory_DF.shape}")
    logger.debug(f"Head:\n{DailyInventory_DF.head()}")

    # Prepare data for the monthly charge report.
    MonthlyChargeReport_DF = pd.merge(
        DailyInventory_DF,
        DailyShippedSKUQty_DF, 
        on=['Date', 'SKU'],
        how='left'
    ).fillna({'TotalQtyShipped': 0}) 

    MonthlyChargeReport_DF = pd.merge(
        MonthlyChargeReport_DF,
        DailyOrderCount_DF, 
        on='Date',
        how='left'
    ).fillna({'CountOfOrders': 0}) 

    # Calculate space rental charge.
    space_rental_rate = rates.get('SpaceRentalRate', 0.0)
    MonthlyChargeReport_DF['PalletsUsed'] = MonthlyChargeReport_DF.apply(
        lambda row: math.ceil(row['EOD_Qty'] / pallet_counts.get(row['SKU'], 1)) if pallet_counts.get(row['SKU'], 1) > 0 else 0,
        axis=1
    )
    MonthlyChargeReport_DF['Space_Rental_Charge_Per_SKU'] = MonthlyChargeReport_DF['PalletsUsed'] * space_rental_rate

    # Aggregate daily space rental charge.
    DailySpaceRentalCharge = MonthlyChargeReport_DF.groupby('Date')['Space_Rental_Charge_Per_SKU'].sum().reset_index()
    DailySpaceRentalCharge.rename(columns={'Space_Rental_Charge_Per_SKU': 'Space_Rental_Charge'}, inplace=True)

    # Combine daily order counts, space rental, and total packages shipped for final daily report.
    FinalDailyReport_DF = pd.merge(
        DailyOrderCount_DF, 
        DailySpaceRentalCharge,
        on='Date',
        how='left'
    ).fillna({'Space_Rental_Charge': 0})

    DailyPackagesShipped = DailyShippedSKUQty_DF.groupby('Date')['TotalQtyShipped'].sum().reset_index()
    DailyPackagesShipped.rename(columns={'TotalQtyShipped': 'TotalPackagesShipped'}, inplace=True)

    FinalDailyReport_DF = pd.merge(
        FinalDailyReport_DF,
        DailyPackagesShipped,
        on='Date',
        how='left'
    ).fillna({'TotalPackagesShipped': 0})

    # Calculate final charges.
    order_charge_rate = rates.get('OrderCharge', 0.0)
    package_charge_rate = rates.get('PackageCharge', 0.0)

    FinalDailyReport_DF['Orders_Charge'] = FinalDailyReport_DF['CountOfOrders'] * order_charge_rate
    FinalDailyReport_DF['Packages_Charge'] = FinalDailyReport_DF['TotalPackagesShipped'] * package_charge_rate
    FinalDailyReport_DF['Total_Charge'] = (
        FinalDailyReport_DF['Orders_Charge'] + 
        FinalDailyReport_DF['Packages_Charge'] + 
        FinalDailyReport_DF['Space_Rental_Charge']
    )

    # Round financial columns.
    financial_columns = ['Orders_Charge', 'Packages_Charge', 'Space_Rental_Charge', 'Total_Charge']
    for col in financial_columns:
        if col in FinalDailyReport_DF.columns:
            FinalDailyReport_DF[col] = FinalDailyReport_DF[col].round(2)

    # Define final output columns and pivot shipped quantities.
    output_columns = [
        'Date', '# Of Orders', '17612_Shipped', '17904_Shipped', '17914_Shipped', '18675_Shipped',
        'Orders_Charge', 'Packages_Charge', 'Space_Rental_Charge', 'Total_Charge'
    ]

    pivot_shipped_qty = DailyShippedSKUQty_DF.pivot_table(
        index='Date', 
        columns='SKU',
        values='TotalQtyShipped', 
        fill_value=0
    ).reset_index()

    column_rename_map = {f'{sku}': f'{sku}_Shipped' for sku in pallet_counts.keys()} 
    pivot_shipped_qty.rename(columns=column_rename_map, inplace=True)

    # Merge pivoted shipped quantities into the final daily report.
    MonthlyChargeReport_DF_Final = pd.merge(
        FinalDailyReport_DF,
        pivot_shipped_qty,
        on='Date',
        how='left'
    ).fillna(0) 

    MonthlyChargeReport_DF_Final.rename(columns={'CountOfOrders': '# Of Orders'}, inplace=True)

    # Ensure all expected SKU columns are present, even if no shipments occurred.
    for sku_key in pallet_counts.keys():
        col_name = f'{sku_key}_Shipped'
        if col_name not in MonthlyChargeReport_DF_Final.columns:
            MonthlyChargeReport_DF_Final[col_name] = 0
    
    MonthlyChargeReport_DF_Final = MonthlyChargeReport_DF_Final[output_columns]
    
    logger.info(f"Monthly Charge Report (Daily) prepared. Shape: {MonthlyChargeReport_DF_Final.shape}")
    logger.debug(f"Head:\n{MonthlyChargeReport_DF_Final.head()}")

    # Calculate monthly totals row.
    MonthlyTotals_DF = pd.DataFrame([{
        'Date': 'Monthly Totals',
        '# Of Orders': MonthlyChargeReport_DF_Final['# Of Orders'].sum(),
        '17612_Shipped': MonthlyChargeReport_DF_Final['17612_Shipped'].sum() if '17612_Shipped' in MonthlyChargeReport_DF_Final.columns else 0,
        '17904_Shipped': MonthlyChargeReport_DF_Final['17904_Shipped'].sum() if '17904_Shipped' in MonthlyChargeReport_DF_Final.columns else 0,
        '17914_Shipped': MonthlyChargeReport_DF_Final['17914_Shipped'].sum() if '17914_Shipped' in MonthlyChargeReport_DF_Final.columns else 0,
        '18675_Shipped': MonthlyChargeReport_DF_Final['18675_Shipped'].sum() if '18675_Shipped' in MonthlyChargeReport_DF_Final.columns else 0,
        'Orders_Charge': MonthlyChargeReport_DF_Final['Orders_Charge'].sum().round(2), 
        'Packages_Charge': MonthlyChargeReport_DF_Final['Packages_Charge'].sum().round(2), 
        'Space_Rental_Charge': MonthlyChargeReport_DF_Final['Space_Rental_Charge'].sum().round(2), 
        'Total_Charge': MonthlyChargeReport_DF_Final['Total_Charge'].sum().round(2) 
    }])

    logger.info(f"Monthly Totals prepared. Head:\n{MonthlyTotals_DF.head()}")


    logger.info("Attempting to write Monthly Charge Report to Google Sheets...")
    write_google_sheet_data( # Using imported function
        google_sheet_id,
        monthly_charge_report_tab_name + "!A1", 
        service_account_credentials_path, 
        MonthlyChargeReport_DF_Final 
    )
    # Write monthly totals below the daily report, with a couple of empty rows for spacing.
    start_row_for_totals = len(MonthlyChargeReport_DF_Final) + 3 
    write_google_sheet_data( # Using imported function
        google_sheet_id,
        monthly_charge_report_tab_name + f"!A{start_row_for_totals}", 
        service_account_credentials_path, 
        MonthlyTotals_DF 
    )
    logger.info("Monthly Charge Report writing process complete.")

    return DailyInventory_DF, DailyShippedSKUQty_DF 

# This block is for independent testing of the module.
if __name__ == "__main__":
    # Add the project root to the Python path to enable imports from utils and services
    # This path is relative to the current file (monthly_report_generator.py)
    # monthly_report_generator.py is in ORA_Automation/src/services/reporting_logic/
    # So, to get to ORA_Automation, we need to go up three levels (reporting_logic, services, src).
    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..')) 
    if project_root not in sys.path:
        sys.path.insert(0, project_root)

    # Re-import setup_logging after path adjustment
    from utils.logging_config import setup_logging # Ensure this is imported here for direct run
    # Ensure logging is only configured once if this script is run as main.
    _log_dir = os.path.join(project_root, 'logs') 
    _log_file = os.path.join(_log_dir, 'app.log')
    if not logging.getLogger().handlers:
        setup_logging(log_file_path=_log_file, log_level=logging.DEBUG, enable_console_logging=True)
    logger = logging.getLogger(__name__)

    logger.info("Starting independent test of Monthly Report Generator module...")

    # --- Dummy Data and Configuration for Testing ---
    # These mimic the outputs from report_data_loader.py, shipment_processor.py, and inventory_calculations.py
    # Replace with your actual Sheet ID and service account path for a real test.
    DUMMY_GOOGLE_SHEET_ID = '1SMewCScZp0U4QtdXMp8ZhT3oxefzKHu-Hq2BAXtCeoo' 
    DUMMY_MONTHLY_REPORT_TAB = 'Monthly Charge Report' # Ensure this tab exists in your Google Sheet
    DUMMY_SERVICE_ACCOUNT_KEY_PATH = r"C:\Users\NathanNeely\Projects\ORA_Automation\config\ora-automation-project-2345f75740f8.json"

    # Dummy Rates, Pallet Counts, Initial Inventory (from ORA_Configuration)
    DUMMY_RATES = {'OrderCharge': 4.25, 'PackageCharge': 0.75, 'SpaceRentalRate': 0.45}
    DUMMY_PALLET_COUNTS = {'17612': 48, '17904': 64, '17914': 80, '18675': 48}
    DUMMY_INITIAL_INVENTORY_MAP = {'17612': 615, '17904': 214, '17914': 416, '18675': 776}
    
    # Dummy BUNDLE_CONFIG (from your global config)
    DUMMY_BUNDLE_CONFIG = {
        "18075": {"component_id": "17913", "multiplier": 1},
        "18225": {"component_id": "17612", "multiplier": 40}, 
        "18605": [
            {"component_id": "17612", "multiplier": 4},
            {"component_id": "17914", "multiplier": 1},
            {"component_id": "17904", "multiplier": 1},
        ],
    }

    # Dummy raw_golden_test_data_raw (mimicking data read from sheet)
    DUMMY_RAW_GOLDEN_TEST_DATA = [
        ['Date', 'Order_Number', 'Transaction_Type', 'SKU_With_Lot', 'Quantity_Shipped', 'ItemName', 'Weight', 'Dimensions'],
        ['2025-06-01', 'ORD100', 'ShippedItem', '17612', '10', 'OraCare Health Rinse', '32', ''],
        ['2025-06-01', 'ORD101', 'ShippedItem', '18225', '1', 'OraCare Bundle 30+8', '100', ''], # Expands to 40x 17612
        ['2025-06-02', 'ORD102', 'ShippedItem', '18605', '2', 'Multi-Pack Special', '50', ''], # Expands to 2x (4x 17612, 1x 17914, 1x 17904)
        ['2025-06-02', 'ORD102', 'ShippedItem', '17975', '5', 'Reassure Product', '10', ''], # Non-bundle
        ['2025-06-03', 'ORD103', 'ShippedItem', '17612', '15', 'OraCare Health Rinse', '32', ''],
        ['2025-06-01', 'ORD100', 'ShippedOrder', '', '', '', '', ''], # For order count
        ['2025-06-01', 'ORD101', 'ShippedOrder', '', '', '', '', ''], # For order count
        ['2025-06-02', 'ORD102', 'ShippedOrder', '', '', '', '', ''], # For order count
        ['2025-06-03', 'ORD103', 'ShippedOrder', '', '', '', '', ''], # For order count
    ]

    # Dummy raw_inventory_transactions (mimicking data read from sheet)
    DUMMY_RAW_INVENTORY_TRANSACTIONS = [
        ['Date', 'SKU', 'Quantity', 'TransactionType'],
        ['2025-06-01', '17612', '50', 'Receive'],
        ['2025-06-02', '17914', '100', 'Receive'],
        ['2025-06-02', '17612', '10', 'Repack'],
        ['2025-06-03', '17904', '20', 'Receive'],
    ]

    # Test generate_monthly_charge_report
    logger.info("Testing generate_monthly_charge_report...")
    daily_inventory_df_result, daily_shipped_sku_qty_df_result = generate_monthly_charge_report(
        shipstation_api_key="DUMMY_KEY", # Not used directly in this function, but needed for signature
        shipstation_api_secret="DUMMY_SECRET", # Not used directly in this function, but needed for signature
        google_sheet_id=DUMMY_GOOGLE_SHEET_ID,
        monthly_charge_report_tab_name=DUMMY_MONTHLY_REPORT_TAB,
        service_account_credentials_path=DUMMY_SERVICE_ACCOUNT_KEY_PATH,
        initial_inventory_map=DUMMY_INITIAL_INVENTORY_MAP,
        pallet_counts=DUMMY_PALLET_COUNTS,
        rates=DUMMY_RATES,
        raw_golden_test_data_raw=DUMMY_RAW_GOLDEN_TEST_DATA,
        inventory_transactions_raw=DUMMY_RAW_INVENTORY_TRANSACTIONS,
        bundle_config=DUMMY_BUNDLE_CONFIG
    )

    logger.info(f"Returned Daily Inventory DataFrame shape: {daily_inventory_df_result.shape}")
    logger.debug(f"Daily Inventory DataFrame head:\n{daily_inventory_df_result.head()}")
    logger.info(f"Returned Daily Shipped SKU Quantity DataFrame shape: {daily_shipped_sku_qty_df_result.shape}")
    logger.debug(f"Daily Shipped SKU Quantity DataFrame head:\n{daily_shipped_sku_qty_df_result.head()}")

    logger.info("Independent test of Monthly Report Generator module finished.")
