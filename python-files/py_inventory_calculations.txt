import pandas as pd
import logging
import datetime # For pd.to_datetime in testing block

# Setup logging for this module. This assumes setup_logging from utils.logging_config
# has already been called in the main application entry point.
logger = logging.getLogger(__name__)

def calculate_daily_inventory(
    initial_inventory_map: dict, 
    all_skus: list, 
    all_dates: pd.DatetimeIndex, 
    daily_movements_df: pd.DataFrame
) -> pd.DataFrame:
    """
    Calculates daily Beginning of Day (BOD) and End of Day (EOD) inventory quantities
    for each SKU using a recursive-like approach in Pandas, considering shipments,
    received items, and repacked items.

    Args:
        initial_inventory_map (dict): A dictionary mapping SKU to its initial EOD quantity
                                      from the prior period (e.g., prior week's EOD).
        all_skus (list): A list of all relevant SKU IDs to track inventory for.
        all_dates (pd.DatetimeIndex): A Pandas DatetimeIndex representing all dates
                                      in the reporting period.
        daily_movements_df (pd.DataFrame): A DataFrame containing daily movements per SKU,
                                           with columns: 'Date', 'SKU', 'ShippedQty',
                                           'ReceivedQty', 'RepackedQty'.

    Returns:
        pd.DataFrame: A DataFrame with daily inventory, including 'Date', 'SKU',
                      'BOD_Qty', and 'EOD_Qty'.
    """
    logger.info("Calculating daily inventory (BOD/EOD) for all SKUs and dates...")

    # Create a MultiIndex for all possible Date-SKU combinations.
    idx = pd.MultiIndex.from_product([pd.to_datetime(all_dates).normalize(), all_skus], names=['Date', 'SKU'])
    daily_inventory_df = pd.DataFrame(index=idx).reset_index()

    # Ensure date and SKU types are consistent for merging.
    daily_movements_df['Date'] = pd.to_datetime(daily_movements_df['Date']).dt.normalize()
    daily_movements_df['SKU'] = daily_movements_df['SKU'].astype(str)

    # Merge daily movements (Shipped, Received, Repacked) into the full daily inventory grid.
    # Fill NaN values with 0 where there were no movements.
    daily_inventory_df = pd.merge(
        daily_inventory_df,
        daily_movements_df,
        on=['Date', 'SKU'],
        how='left'
    ).fillna({
        'ShippedQty': 0,
        'ReceivedQty': 0,
        'RepackedQty': 0
    })
    
    # Initialize BOD and EOD quantities.
    daily_inventory_df['BOD_Qty'] = 0
    daily_inventory_df['EOD_Qty'] = 0

    # Sort by SKU and Date to facilitate cumulative calculations.
    daily_inventory_df = daily_inventory_df.sort_values(by=['SKU', 'Date']).reset_index(drop=True)

    # Perform cumulative inventory calculation for each SKU.
    for sku in all_skus:
        sku_data = daily_inventory_df[daily_inventory_df['SKU'] == sku].copy()
        
        # Get the initial EOD quantity for the SKU from the map (e.g., prior week's EOD).
        # Use .get() with a default of 0 to handle cases where an SKU might not be in the initial map.
        initial_eod_for_sku = initial_inventory_map.get(sku, 0)

        if not sku_data.empty:
            # Set the Beginning of Day quantity for the first day for this SKU.
            sku_data.loc[sku_data.index[0], 'BOD_Qty'] = initial_eod_for_sku
            
            # Calculate End of Day quantity for the first day.
            sku_data.loc[sku_data.index[0], 'EOD_Qty'] = (
                sku_data.loc[sku_data.index[0], 'BOD_Qty']
                - sku_data.loc[sku_data.index[0], 'ShippedQty']
                + sku_data.loc[sku_data.index[0], 'ReceivedQty']
                + sku_data.loc[sku_data.index[0], 'RepackedQty']
            )

            # Iterate through subsequent days to calculate BOD and EOD.
            for i in range(1, len(sku_data)):
                # Current day's BOD is previous day's EOD.
                sku_data.loc[sku_data.index[i], 'BOD_Qty'] = sku_data.loc[sku_data.index[i-1], 'EOD_Qty']
                
                # Calculate current day's EOD.
                sku_data.loc[sku_data.index[i], 'EOD_Qty'] = (
                    sku_data.loc[sku_data.index[i], 'BOD_Qty']
                    - sku_data.loc[sku_data.index[i], 'ShippedQty']
                    + sku_data.loc[sku_data.index[i], 'ReceivedQty']
                    + sku_data.loc[sku_data.index[i], 'RepackedQty']
                )
        
        # Update the main daily_inventory_df with the calculated BOD/EOD quantities for the current SKU.
        daily_inventory_df.loc[daily_inventory_df['SKU'] == sku, ['BOD_Qty', 'EOD_Qty']] = sku_data[['BOD_Qty', 'EOD_Qty']].values

    logger.info(f"Daily Inventory Calculation complete. Resulting DataFrame shape: {daily_inventory_df.shape}")
    logger.debug(f"Daily Inventory DataFrame head:\n{daily_inventory_df.head()}")
    return daily_inventory_df

def calculate_current_inventory(daily_inventory_df: pd.DataFrame, key_skus: list) -> pd.DataFrame:
    """
    Extracts the most recent End of Day (EOD) quantity for each specified key SKU
    from the daily inventory DataFrame. This represents the current inventory level.

    Args:
        daily_inventory_df (pd.DataFrame): DataFrame containing daily inventory levels
                                           (e.g., from calculate_daily_inventory).
        key_skus (list): A list of SKU IDs for which to calculate the current inventory.

    Returns:
        pd.DataFrame: A DataFrame with 'SKU' and 'Current Quantity' for each key SKU.
                      Returns 0 for 'Current Quantity' if an SKU is not found in the inventory data.
    """
    logger.info("Extracting current inventory for key SKUs...")
    current_inventory_data = []

    if daily_inventory_df.empty:
        logger.warning("Daily inventory DataFrame is empty. Cannot calculate current inventory.")
        return pd.DataFrame(columns=['SKU', 'Current Quantity'])

    # Ensure 'Date' is datetime and sort by date in descending order to easily get the latest EOD.
    daily_inventory_df['Date'] = pd.to_datetime(daily_inventory_df['Date'])
    daily_inventory_df_sorted = daily_inventory_df.sort_values(by='Date', ascending=False)

    for sku in key_skus:
        # Filter for the current SKU and get its latest EOD quantity.
        sku_data = daily_inventory_df_sorted[daily_inventory_df_sorted['SKU'] == sku].copy()
        
        # Get the first (most recent) EOD quantity, or 0 if no data for the SKU.
        latest_eod = sku_data['EOD_Qty'].iloc[0] if not sku_data.empty else 0
        
        current_inventory_data.append({
            'SKU': sku,
            'Current Quantity': latest_eod
        })
    
    current_inventory_df = pd.DataFrame(current_inventory_data)
    logger.info(f"Current Inventory Calculation complete. Resulting DataFrame shape: {current_inventory_df.shape}")
    logger.debug(f"Current Inventory DataFrame head:\n{current_inventory_df.head()}")
    return current_inventory_df

# This block is for independent testing of the module.
if __name__ == "__main__":
    # Simulate logging setup for independent module testing
    logging.basicConfig(level=logging.DEBUG, 
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    logger.info("Starting independent test of Inventory Calculations module...")

    # --- Dummy Data for calculate_daily_inventory ---
    # all_skus and all_dates for the full grid
    dummy_all_skus = ['17612', '17904', '17914']
    dummy_all_dates = pd.date_range(start='2025-06-01', end='2025-06-03', freq='D')

    # initial_inventory_map for prior period EOD
    dummy_initial_inventory_map = {
        '17612': 1000,
        '17904': 500,
        '17914': 750
    }

    # daily_movements_df simulating Shipped, Received, Repacked quantities
    dummy_daily_movements_df = pd.DataFrame([
        {'Date': '2025-06-01', 'SKU': '17612', 'ShippedQty': 100, 'ReceivedQty': 50, 'RepackedQty': 0},
        {'Date': '2025-06-01', 'SKU': '17904', 'ShippedQty': 20, 'ReceivedQty': 0, 'RepackedQty': 0},
        {'Date': '2025-06-02', 'SKU': '17612', 'ShippedQty': 50, 'ReceivedQty': 0, 'RepackedQty': 10},
        {'Date': '2025-06-02', 'SKU': '17914', 'ShippedQty': 30, 'ReceivedQty': 100, 'RepackedQty': 0},
        {'Date': '2025-06-03', 'SKU': '17612', 'ShippedQty': 200, 'ReceivedQty': 0, 'RepackedQty': 0},
    ])

    logger.info("Testing calculate_daily_inventory...")
    daily_inventory_result_df = calculate_daily_inventory(
        dummy_initial_inventory_map,
        dummy_all_skus,
        dummy_all_dates,
        dummy_daily_movements_df
    )
    logger.info(f"Daily Inventory Result DataFrame:\n{daily_inventory_result_df}")

    # --- Dummy Data for calculate_current_inventory ---
    # Using the result from daily_inventory_result_df for testing
    dummy_key_skus = ['17612', '17904', '17914', '99999'] # Add a non-existent SKU

    logger.info("Testing calculate_current_inventory...")
    current_inventory_result_df = calculate_current_inventory(
        daily_inventory_result_df,
        dummy_key_skus
    )
    logger.info(f"Current Inventory Result DataFrame:\n{current_inventory_result_df}")

    logger.info("Independent test of Inventory Calculations module finished.")
